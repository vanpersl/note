1.wait和notify用来实现多线程之间的协调，wait表示让线程进入到阻塞状态，notify表示让阻塞的线程唤醒。

2.wait和notify必然是成对出现的，如果一个线程被wait()方法阻塞，那么必然需要另外一个线程通过notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。

3.在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程t1修改共享变量s，线程t2获取修改后的共享变量s，从而完成数据通信。

![讲一下wait和notify这个为什么要在synchronized代码块中？](https://p6.toutiaoimg.com/origin/tos-cn-i-qvj2lq49k0/f0891042b7ff4aa4956ead559b0565a8?from=pc)



但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程t2在访问共享变量s之前，必须要知道线程t1已经修改过了共享变量s，否则就需要等待。

同时，线程t1修改过了共享变量S之后，还需要通知在等待中的线程t2。

所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线程在什么条件下等待，什么条件下唤醒。

4.而Synchronized同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。

5.所以这也是为什么wait/notify需要放在Synchronized同步代码块中的原因，有了Synchronized同步锁，就可以实现对多个通信线程之间的互斥，实现条件等待和条件唤醒。

6.另外，为了避免wait/notify的错误使用，jdk强制要求把wait/notify写在同步代码块里面，否则会抛出
IllegalMonitorStateException

7.最后，基于wait/notify的特性，非常适合实现生产者消费者的模型，比如说用wait/notify来实现连接池就绪前的等待与就绪后的唤醒。

以上就是我对wait/notify这个问题的理解。